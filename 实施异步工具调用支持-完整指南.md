# å®æ–½å¼‚æ­¥å·¥å…·è°ƒç”¨æ”¯æŒ - å®Œæ•´æŒ‡å—

## ğŸ“‹ **é¡¹ç›®æ¦‚è§ˆ**

**ç›®æ ‡**ï¼šä¸ºSpring AIæ·»åŠ å¯é€‰çš„å¼‚æ­¥å·¥å…·è°ƒç”¨æ”¯æŒ

**åŸåˆ™**ï¼š
- âœ… å‘åå…¼å®¹100%ï¼ˆç°æœ‰ä»£ç æ— éœ€ä¿®æ”¹ï¼‰
- âœ… å¯é€‰å‡çº§ï¼ˆç”¨æˆ·å¯ä»¥é€‰æ‹©ä½•æ—¶ä½¿ç”¨å¼‚æ­¥ï¼‰
- âœ… æ¸è¿›å¼å®æ–½ï¼ˆåˆ†é˜¶æ®µå®Œæˆï¼‰
- âœ… æ€§èƒ½æå‡5-10å€

**é¢„è®¡æ—¶é—´**ï¼š
- Phase 1ï¼ˆæ ¸å¿ƒæ¥å£ï¼‰ï¼š1-2å‘¨
- Phase 2ï¼ˆæ¡†æ¶é›†æˆï¼‰ï¼š2-3å‘¨
- Phase 3ï¼ˆæ¨¡å‹æ›´æ–°ï¼‰ï¼š2-3å‘¨
- Phase 4ï¼ˆæµ‹è¯•å’Œæ–‡æ¡£ï¼‰ï¼š1-2å‘¨
- **æ€»è®¡**ï¼š6-10å‘¨

---

## ğŸ¯ **é˜¶æ®µåˆ’åˆ†**

```
Phase 1: æ ¸å¿ƒæ¥å£è®¾è®¡
â”œâ”€ AsyncToolCallbackæ¥å£
â”œâ”€ ToolExecutionModeæšä¸¾
â””â”€ å‘åå…¼å®¹éªŒè¯

Phase 2: æ¡†æ¶å±‚é›†æˆ
â”œâ”€ ToolCallingManageræ‰©å±•
â”œâ”€ DefaultToolCallingManagerå®ç°
â””â”€ å·¥å…·è§£æå™¨æ›´æ–°

Phase 3: æ¨¡å‹å±‚æ›´æ–°
â”œâ”€ æ›´æ–°11ä¸ªChatModelå®ç°
â”œâ”€ ç§»é™¤boundedElasticï¼ˆå¼‚æ­¥å·¥å…·ï¼‰
â””â”€ ä¿ç•™boundedElasticï¼ˆåŒæ­¥å·¥å…·é™çº§ï¼‰

Phase 4: æµ‹è¯•å’Œæ–‡æ¡£
â”œâ”€ å•å…ƒæµ‹è¯•
â”œâ”€ é›†æˆæµ‹è¯•
â”œâ”€ æ€§èƒ½åŸºå‡†æµ‹è¯•
â”œâ”€ è¿ç§»æŒ‡å—
â””â”€ APIæ–‡æ¡£
```

---

## ğŸ“ **Phase 1: æ ¸å¿ƒæ¥å£è®¾è®¡**

### **1.1 åˆ›å»ºAsyncToolCallbackæ¥å£**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/main/java/org/springframework/ai/tool/AsyncToolCallback.java`

```java
/*
 * Copyright 2023-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.ai.tool;

import reactor.core.publisher.Mono;
import org.springframework.ai.chat.model.ToolContext;
import org.springframework.lang.Nullable;

/**
 * å¼‚æ­¥å·¥å…·å›è°ƒæ¥å£ï¼Œæ”¯æŒéé˜»å¡çš„å·¥å…·æ‰§è¡Œã€‚
 *
 * <p>ç›¸æ¯”ä¼ ç»Ÿçš„{@link ToolCallback}ï¼Œå¼‚æ­¥å·¥å…·ä¸ä¼šé˜»å¡çº¿ç¨‹ï¼Œ
 * é€‚åˆéœ€è¦è°ƒç”¨å¤–éƒ¨APIã€æ•°æ®åº“ç­‰I/Oæ“ä½œçš„åœºæ™¯ã€‚
 *
 * <p><strong>ä½¿ç”¨å¼‚æ­¥å·¥å…·å¯ä»¥æ˜¾è‘—æå‡å¹¶å‘æ€§èƒ½ï¼Œé¿å…çº¿ç¨‹æ± è€—å°½ã€‚</strong>
 *
 * <h2>åŸºæœ¬ç”¨æ³•</h2>
 * <pre>{@code
 * @Component
 * public class AsyncWeatherTool implements AsyncToolCallback {
 *
 *     private final WebClient webClient;
 *
 *     public AsyncWeatherTool(WebClient.Builder builder) {
 *         this.webClient = builder.baseUrl("https://api.weather.com").build();
 *     }
 *
 *     @Override
 *     public Mono<String> callAsync(String toolInput, ToolContext context) {
 *         WeatherRequest request = parseInput(toolInput);
 *         return webClient.get()
 *             .uri("/weather?city=" + request.getCity())
 *             .retrieve()
 *             .bodyToMono(String.class)
 *             .timeout(Duration.ofSeconds(5));
 *     }
 *
 *     @Override
 *     public ToolDefinition getToolDefinition() {
 *         return ToolDefinition.builder()
 *             .name("get_weather")
 *             .description("è·å–åŸå¸‚å¤©æ°”ä¿¡æ¯")
 *             .inputTypeSchema(WeatherRequest.class)
 *             .build();
 *     }
 * }
 * }</pre>
 *
 * <h2>å‘åå…¼å®¹</h2>
 * <p>å¦‚æœåªå®ç°äº†å¼‚æ­¥æ–¹æ³•ï¼ŒåŒæ­¥æ–¹æ³•{@link #call(String, ToolContext)}
 * ä¼šè‡ªåŠ¨è°ƒç”¨{@link #callAsync(String, ToolContext)}å¹¶é˜»å¡ç­‰å¾…ç»“æœã€‚
 *
 * @author Spring AI Team
 * @since 1.2.0
 * @see ToolCallback
 * @see ToolContext
 */
public interface AsyncToolCallback extends ToolCallback {

    /**
     * å¼‚æ­¥æ‰§è¡Œå·¥å…·è°ƒç”¨ã€‚
     *
     * <p>æ­¤æ–¹æ³•ä¸ä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ª{@link Mono}ï¼Œ
     * å½“å·¥å…·æ‰§è¡Œå®Œæˆæ—¶å‘å‡ºç»“æœã€‚
     *
     * <h3>æœ€ä½³å®è·µ</h3>
     * <ul>
     * <li>ä½¿ç”¨{@link reactor.core.publisher.Mono#timeout(Duration)}
     *     è®¾ç½®è¶…æ—¶ï¼Œé¿å…æ— é™ç­‰å¾…</li>
     * <li>ä½¿ç”¨{@link reactor.core.publisher.Mono#retry(long)}
     *     å¤„ç†ä¸´æ—¶æ€§æ•…éšœ</li>
     * <li>ä½¿ç”¨{@link reactor.core.publisher.Mono#onErrorResume(Function)}
     *     ä¼˜é›…å¤„ç†é”™è¯¯</li>
     * <li>é¿å…åœ¨å¼‚æ­¥æ–¹æ³•ä¸­ä½¿ç”¨é˜»å¡è°ƒç”¨ï¼ˆå¦‚{@code Thread.sleep}ï¼‰</li>
     * </ul>
     *
     * @param toolInput å·¥å…·è¾“å…¥å‚æ•°ï¼ˆJSONæ ¼å¼ï¼‰
     * @param context å·¥å…·æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå¯èƒ½ä¸ºnull
     * @return å¼‚æ­¥è¿”å›å·¥å…·æ‰§è¡Œç»“æœçš„Mono
     * @throws org.springframework.ai.tool.execution.ToolExecutionException å¦‚æœå·¥å…·æ‰§è¡Œå¤±è´¥
     */
    Mono<String> callAsync(String toolInput, @Nullable ToolContext context);

    /**
     * æ£€æŸ¥æ˜¯å¦æ”¯æŒå¼‚æ­¥è°ƒç”¨ã€‚
     *
     * <p>é»˜è®¤è¿”å›{@code true}ã€‚å¦‚æœå­ç±»é‡å†™æ­¤æ–¹æ³•å¹¶è¿”å›{@code false}ï¼Œ
     * æ¡†æ¶å°†ä½¿ç”¨åŒæ­¥è°ƒç”¨{@link #call(String, ToolContext)}ï¼Œ
     * å¹¶åœ¨ç‹¬ç«‹çº¿ç¨‹æ± ï¼ˆboundedElasticï¼‰ä¸­æ‰§è¡Œã€‚
     *
     * <p>å¯ä»¥æ ¹æ®è¿è¡Œæ—¶æ¡ä»¶åŠ¨æ€å†³å®šæ˜¯å¦ä½¿ç”¨å¼‚æ­¥ï¼š
     * <pre>{@code
     * @Override
     * public boolean supportsAsync() {
     *     // ä»…åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨å¼‚æ­¥
     *     return environment.getProperty("spring.profiles.active").equals("production");
     * }
     * }</pre>
     *
     * @return å¦‚æœæ”¯æŒå¼‚æ­¥è°ƒç”¨è¿”å›trueï¼Œå¦åˆ™è¿”å›false
     */
    default boolean supportsAsync() {
        return true;
    }

    /**
     * åŒæ­¥æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆå‘åå…¼å®¹ï¼‰ã€‚
     *
     * <p>é»˜è®¤å®ç°ä¼šè°ƒç”¨{@link #callAsync(String, ToolContext)}
     * å¹¶é˜»å¡ç­‰å¾…ç»“æœã€‚è¿™ç¡®ä¿äº†å‘åå…¼å®¹æ€§ï¼Œä½†ä¼šå¤±å»å¼‚æ­¥çš„æ€§èƒ½ä¼˜åŠ¿ã€‚
     *
     * <p><strong>æ³¨æ„</strong>ï¼šå¦‚æœä½ çš„å·¥å…·éœ€è¦åŒæ—¶æ”¯æŒåŒæ­¥å’Œå¼‚æ­¥è°ƒç”¨ï¼Œ
     * å¯ä»¥é‡å†™æ­¤æ–¹æ³•æä¾›ä¼˜åŒ–çš„åŒæ­¥å®ç°ã€‚
     *
     * @param toolInput å·¥å…·è¾“å…¥å‚æ•°ï¼ˆJSONæ ¼å¼ï¼‰
     * @param context å·¥å…·æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå¯èƒ½ä¸ºnull
     * @return å·¥å…·æ‰§è¡Œç»“æœ
     * @throws org.springframework.ai.tool.execution.ToolExecutionException å¦‚æœå·¥å…·æ‰§è¡Œå¤±è´¥
     */
    @Override
    default String call(String toolInput, @Nullable ToolContext context) {
        // é˜»å¡ç­‰å¾…å¼‚æ­¥ç»“æœï¼ˆé™çº§æ–¹æ¡ˆï¼‰
        return callAsync(toolInput, context).block();
    }
}
```

---

### **1.2 åˆ›å»ºToolExecutionModeæšä¸¾ï¼ˆå¯é€‰ï¼‰**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/main/java/org/springframework/ai/model/tool/ToolExecutionMode.java`

```java
/*
 * Copyright 2023-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.ai.model.tool;

/**
 * å·¥å…·æ‰§è¡Œæ¨¡å¼æšä¸¾ã€‚
 *
 * <p>å®šä¹‰äº†å·¥å…·è°ƒç”¨çš„ä¸åŒæ‰§è¡Œæ¨¡å¼ï¼Œç”¨äºæ€§èƒ½ä¼˜åŒ–å’Œèµ„æºç®¡ç†ã€‚
 *
 * @author Spring AI Team
 * @since 1.2.0
 */
public enum ToolExecutionMode {

    /**
     * åŒæ­¥æ‰§è¡Œæ¨¡å¼ã€‚
     *
     * <p>å·¥å…·æ‰§è¡Œä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼Œç›´åˆ°å®Œæˆã€‚
     * æ­¤æ¨¡å¼é€‚ç”¨äºï¼š
     * <ul>
     * <li>å¿«é€Ÿæ‰§è¡Œçš„å·¥å…·ï¼ˆ< 100msï¼‰</li>
     * <li>çº¯è®¡ç®—ä»»åŠ¡</li>
     * <li>ä¸æ¶‰åŠI/Oçš„æ“ä½œ</li>
     * </ul>
     *
     * <p><strong>æ€§èƒ½å½±å“</strong>ï¼šä¼šå ç”¨çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹ï¼Œ
     * é«˜å¹¶å‘åœºæ™¯ä¸‹å¯èƒ½æˆä¸ºç“¶é¢ˆã€‚
     */
    SYNC,

    /**
     * å¼‚æ­¥æ‰§è¡Œæ¨¡å¼ã€‚
     *
     * <p>å·¥å…·æ‰§è¡Œä¸ä¼šé˜»å¡è°ƒç”¨çº¿ç¨‹ï¼Œä½¿ç”¨å“åº”å¼ç¼–ç¨‹æ¨¡å‹ã€‚
     * æ­¤æ¨¡å¼é€‚ç”¨äºï¼š
     * <ul>
     * <li>æ¶‰åŠç½‘ç»œI/Oçš„æ“ä½œï¼ˆHTTPè¯·æ±‚ã€æ•°æ®åº“æŸ¥è¯¢ï¼‰</li>
     * <li>é•¿æ—¶é—´è¿è¡Œçš„ä»»åŠ¡ï¼ˆ> 1ç§’ï¼‰</li>
     * <li>éœ€è¦é«˜å¹¶å‘çš„åœºæ™¯</li>
     * </ul>
     *
     * <p><strong>æ€§èƒ½ä¼˜åŠ¿</strong>ï¼šä¸å ç”¨çº¿ç¨‹ï¼Œå¯ä»¥æ”¯æŒ
     * æ•°åƒç”šè‡³æ•°ä¸‡çš„å¹¶å‘å·¥å…·è°ƒç”¨ã€‚
     */
    ASYNC,

    /**
     * å¹¶è¡Œæ‰§è¡Œæ¨¡å¼ï¼ˆæœªæ¥æ‰©å±•ï¼‰ã€‚
     *
     * <p>å¤šä¸ªå·¥å…·è°ƒç”¨å¯ä»¥å¹¶è¡Œæ‰§è¡Œï¼Œè€Œä¸æ˜¯ä¸²è¡Œã€‚
     * é€‚ç”¨äºå·¥å…·è°ƒç”¨ä¹‹é—´æ²¡æœ‰ä¾èµ–å…³ç³»çš„åœºæ™¯ã€‚
     */
    PARALLEL,

    /**
     * æµå¼æ‰§è¡Œæ¨¡å¼ï¼ˆæœªæ¥æ‰©å±•ï¼‰ã€‚
     *
     * <p>å·¥å…·å¯ä»¥è¿”å›æµå¼ç»“æœï¼Œè€Œä¸æ˜¯ç­‰å¾…å…¨éƒ¨å®Œæˆã€‚
     * é€‚ç”¨äºé•¿æ—¶é—´è¿è¡Œä¸”éœ€è¦å®æ—¶åé¦ˆçš„ä»»åŠ¡ã€‚
     */
    STREAMING
}
```

---

### **1.3 æ›´æ–°ToolMetadataï¼ˆæ”¯æŒæ‰§è¡Œæ¨¡å¼æ ‡è®°ï¼‰**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/main/java/org/springframework/ai/tool/metadata/ToolMetadata.java`

åœ¨ç°æœ‰çš„`ToolMetadata`ç±»ä¸­æ·»åŠ ï¼š

```java
/**
 * å·¥å…·çš„æ‰§è¡Œæ¨¡å¼ã€‚
 * 
 * @return æ‰§è¡Œæ¨¡å¼ï¼Œé»˜è®¤ä¸ºSYNC
 * @since 1.2.0
 */
default ToolExecutionMode executionMode() {
    return ToolExecutionMode.SYNC;
}
```

---

## ğŸ“ **Phase 2: æ¡†æ¶å±‚é›†æˆ**

### **2.1 æ‰©å±•ToolCallingManageræ¥å£**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/main/java/org/springframework/ai/model/tool/ToolCallingManager.java`

```java
public interface ToolCallingManager {

    /**
     * è§£æå·¥å…·å®šä¹‰ï¼ˆç°æœ‰æ–¹æ³•ï¼‰
     */
    List<ToolDefinition> resolveToolDefinitions(ToolCallingChatOptions chatOptions);

    /**
     * åŒæ­¥æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆç°æœ‰æ–¹æ³•ï¼Œä¿æŒå‘åå…¼å®¹ï¼‰
     */
    ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse);

    /**
     * å¼‚æ­¥æ‰§è¡Œå·¥å…·è°ƒç”¨ï¼ˆæ–°å¢æ–¹æ³•ï¼‰ã€‚
     *
     * <p>å¦‚æœå·¥å…·å®ç°äº†{@link AsyncToolCallback}æ¥å£ä¸”æ”¯æŒå¼‚æ­¥ï¼Œ
     * å°†ä½¿ç”¨éé˜»å¡çš„å¼‚æ­¥æ‰§è¡Œï¼›å¦åˆ™é™çº§åˆ°åŒæ­¥æ‰§è¡Œï¼ˆåœ¨boundedElasticçº¿ç¨‹æ± ä¸­ï¼‰ã€‚
     *
     * <h3>æ€§èƒ½ä¼˜åŠ¿</h3>
     * <p>å¼‚æ­¥æ‰§è¡Œå¯ä»¥æ˜¾è‘—æå‡å¹¶å‘æ€§èƒ½ï¼š
     * <ul>
     * <li>åŒæ­¥æ¨¡å¼ï¼šå—é™äºçº¿ç¨‹æ± å¤§å°ï¼ˆé€šå¸¸80ä¸ªçº¿ç¨‹ï¼‰</li>
     * <li>å¼‚æ­¥æ¨¡å¼ï¼šä¸å—çº¿ç¨‹æ± é™åˆ¶ï¼Œå¯æ”¯æŒæ•°åƒå¹¶å‘</li>
     * </ul>
     *
     * <h3>å‘åå…¼å®¹</h3>
     * <p>å¦‚æœå·¥å…·æœªå®ç°å¼‚æ­¥æ¥å£ï¼Œæ¡†æ¶ä¼šè‡ªåŠ¨é™çº§åˆ°åŒæ­¥æ‰§è¡Œï¼Œ
     * ç¡®ä¿ç°æœ‰ä»£ç æ— éœ€ä¿®æ”¹å³å¯å·¥ä½œã€‚
     *
     * @param prompt åŸå§‹æç¤º
     * @param chatResponse AIæ¨¡å‹çš„å“åº”ï¼ˆåŒ…å«å·¥å…·è°ƒç”¨è¯·æ±‚ï¼‰
     * @return å¼‚æ­¥è¿”å›å·¥å…·æ‰§è¡Œç»“æœçš„Mono
     * @since 1.2.0
     */
    Mono<ToolExecutionResult> executeToolCallsAsync(Prompt prompt, ChatResponse chatResponse);

    /**
     * åˆ›å»ºé»˜è®¤çš„ToolCallingManageræ„å»ºå™¨
     */
    static DefaultToolCallingManager.Builder builder() {
        return DefaultToolCallingManager.builder();
    }
}
```

---

### **2.2 å®ç°DefaultToolCallingManagerçš„å¼‚æ­¥æ–¹æ³•**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/main/java/org/springframework/ai/model/tool/DefaultToolCallingManager.java`

åœ¨ç°æœ‰ç±»ä¸­æ·»åŠ ï¼š

```java
@Override
public Mono<ToolExecutionResult> executeToolCallsAsync(Prompt prompt, ChatResponse chatResponse) {
    Assert.notNull(prompt, "prompt cannot be null");
    Assert.notNull(chatResponse, "chatResponse cannot be null");

    // è·å–å·¥å…·è°ƒç”¨
    Optional<Generation> toolCallGeneration = chatResponse.getResults()
        .stream()
        .filter(g -> !CollectionUtils.isEmpty(g.getOutput().getToolCalls()))
        .findFirst();

    if (toolCallGeneration.isEmpty()) {
        return Mono.error(new IllegalStateException("No tool call requested by the chat model"));
    }

    AssistantMessage assistantMessage = toolCallGeneration.get().getOutput();
    ToolContext toolContext = buildToolContext(prompt, assistantMessage);

    // å¼‚æ­¥æ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
    return executeToolCallsAsync(prompt, assistantMessage, toolContext)
        .map(toolResponseMessage -> {
            List<Message> conversationHistory = buildConversationHistoryAfterToolExecution(
                prompt.getInstructions(),
                assistantMessage,
                toolResponseMessage.toolResponseMessage()
            );

            return ToolExecutionResult.builder()
                .conversationHistory(conversationHistory)
                .returnDirect(toolResponseMessage.returnDirect())
                .build();
        });
}

/**
 * å¼‚æ­¥æ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
 */
private Mono<InternalToolExecutionResult> executeToolCallsAsync(
        Prompt prompt,
        AssistantMessage assistantMessage,
        ToolContext toolContext) {

    List<AssistantMessage.ToolCall> toolCalls = assistantMessage.getToolCalls();
    
    // ä¸ºæ¯ä¸ªå·¥å…·è°ƒç”¨åˆ›å»ºå¼‚æ­¥æ‰§è¡Œä»»åŠ¡
    List<Mono<ToolResponseWithMetadata>> toolResponseMonos = toolCalls.stream()
        .map(toolCall -> executeToolCallAsync(prompt, toolCall, toolContext))
        .toList();

    // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å·¥å…·ï¼ˆä½¿ç”¨zipï¼‰
    return Mono.zip(toolResponseMonos, responses -> {
        // åˆå¹¶æ‰€æœ‰å·¥å…·å“åº”
        List<ToolResponseMessage.ToolResponse> toolResponses = new ArrayList<>();
        Boolean returnDirect = null;

        for (Object response : responses) {
            ToolResponseWithMetadata trm = (ToolResponseWithMetadata) response;
            toolResponses.add(trm.toolResponse());
            
            if (returnDirect == null) {
                returnDirect = trm.returnDirect();
            } else {
                returnDirect = returnDirect && trm.returnDirect();
            }
        }

        return new InternalToolExecutionResult(
            ToolResponseMessage.builder().responses(toolResponses).build(),
            returnDirect != null && returnDirect
        );
    });
}

/**
 * å¼‚æ­¥æ‰§è¡Œå•ä¸ªå·¥å…·è°ƒç”¨
 */
private Mono<ToolResponseWithMetadata> executeToolCallAsync(
        Prompt prompt,
        AssistantMessage.ToolCall toolCall,
        ToolContext toolContext) {

    String toolName = toolCall.name();
    String toolInputArguments = toolCall.arguments();

    // å¤„ç†ç©ºå‚æ•°
    final String finalToolInputArguments;
    if (!StringUtils.hasText(toolInputArguments)) {
        logger.warn("Tool call arguments are null or empty for tool: {}. Using empty JSON object as default.",
                toolName);
        finalToolInputArguments = "{}";
    } else {
        finalToolInputArguments = toolInputArguments;
    }

    // è§£æå·¥å…·å›è°ƒ
    List<ToolCallback> toolCallbacks = List.of();
    if (prompt.getOptions() instanceof ToolCallingChatOptions toolCallingChatOptions) {
        toolCallbacks = toolCallingChatOptions.getToolCallbacks();
    }

    ToolCallback toolCallback = toolCallbacks.stream()
        .filter(tool -> toolName.equals(tool.getToolDefinition().name()))
        .findFirst()
        .orElseGet(() -> this.toolCallbackResolver.resolve(toolName));

    if (toolCallback == null) {
        logger.warn(POSSIBLE_LLM_TOOL_NAME_CHANGE_WARNING, toolName);
        return Mono.error(new IllegalStateException("No ToolCallback found for tool name: " + toolName));
    }

    boolean returnDirect = toolCallback.getToolMetadata().returnDirect();

    // åˆ›å»ºè§‚æµ‹ä¸Šä¸‹æ–‡
    ToolCallingObservationContext observationContext = ToolCallingObservationContext.builder()
        .toolDefinition(toolCallback.getToolDefinition())
        .toolMetadata(toolCallback.getToolMetadata())
        .toolCallArguments(finalToolInputArguments)
        .build();

    // ğŸ” æ£€æŸ¥æ˜¯å¦æ”¯æŒå¼‚æ­¥
    Mono<String> toolResultMono;
    
    if (toolCallback instanceof AsyncToolCallback asyncToolCallback && asyncToolCallback.supportsAsync()) {
        // âœ… å¼‚æ­¥æ‰§è¡Œï¼ˆéé˜»å¡ï¼‰
        logger.debug("Executing tool asynchronously: {}", toolName);
        
        toolResultMono = asyncToolCallback.callAsync(finalToolInputArguments, toolContext)
            .timeout(Duration.ofSeconds(30))  // é»˜è®¤è¶…æ—¶30ç§’
            .onErrorResume(ToolExecutionException.class, ex -> 
                Mono.just(this.toolExecutionExceptionProcessor.process(ex))
            )
            .onErrorResume(ex -> {
                logger.error("Async tool execution failed: {}", toolName, ex);
                ToolExecutionException wrappedException = new ToolExecutionException(
                    toolCallback.getToolDefinition(), ex
                );
                return Mono.just(this.toolExecutionExceptionProcessor.process(wrappedException));
            });
    } else {
        // ğŸ”¶ é™çº§åˆ°åŒæ­¥æ‰§è¡Œï¼ˆåœ¨boundedElasticçº¿ç¨‹æ± ä¸­ï¼‰
        logger.debug("Executing tool synchronously (fallback): {}", toolName);
        
        toolResultMono = Mono.fromCallable(() -> {
            try {
                return toolCallback.call(finalToolInputArguments, toolContext);
            } catch (ToolExecutionException ex) {
                return this.toolExecutionExceptionProcessor.process(ex);
            } catch (Exception ex) {
                ToolExecutionException wrappedException = new ToolExecutionException(
                    toolCallback.getToolDefinition(), ex
                );
                return this.toolExecutionExceptionProcessor.process(wrappedException);
            }
        }).subscribeOn(Schedulers.boundedElastic());  // â† ä»ç„¶éœ€è¦ï¼Œä½†åªç”¨äºåŒæ­¥å·¥å…·
    }

    // åŒ…è£…è§‚æµ‹
    return ToolCallingObservationDocumentation.TOOL_CALL
        .observation(this.observationConvention, DEFAULT_OBSERVATION_CONVENTION, 
            () -> observationContext, this.observationRegistry)
        .observeOn(toolResultMono.map(result -> {
            observationContext.setToolCallResult(result);
            return new ToolResponseWithMetadata(
                new ToolResponseMessage.ToolResponse(toolCall.id(), toolName, result != null ? result : ""),
                returnDirect
            );
        }));
}

/**
 * å†…éƒ¨ç±»ï¼šå·¥å…·å“åº”åŠå…¶å…ƒæ•°æ®
 */
private record ToolResponseWithMetadata(
    ToolResponseMessage.ToolResponse toolResponse,
    boolean returnDirect
) {}
```

---

## ğŸ“ **Phase 3: æ›´æ–°æ¨¡å‹å®ç°**

### **3.1 æ›´æ–°OpenAiChatModelï¼ˆç¤ºä¾‹ï¼‰**

**æ–‡ä»¶**ï¼š`models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiChatModel.java`

æ‰¾åˆ°æµå¼å“åº”çš„å·¥å…·è°ƒç”¨éƒ¨åˆ†ï¼ˆç¬¬365-394è¡Œï¼‰ï¼Œä¿®æ”¹ä¸ºï¼š

```java
// @formatter:off
Flux<ChatResponse> flux = chatResponse.flatMap(response -> {
    if (this.toolExecutionEligibilityPredicate.isToolExecutionRequired(prompt.getOptions(), response)) {
        
        // âœ… ä½¿ç”¨å¼‚æ­¥å·¥å…·è°ƒç”¨ï¼ˆæ–°å®ç°ï¼‰
        return this.toolCallingManager.executeToolCallsAsync(prompt, response)
            .flatMapMany(toolExecutionResult -> {
                if (toolExecutionResult.returnDirect()) {
                    // ç›´æ¥è¿”å›å·¥å…·ç»“æœç»™å®¢æˆ·ç«¯
                    return Flux.just(ChatResponse.builder().from(response)
                        .generations(ToolExecutionResult.buildGenerations(toolExecutionResult))
                        .build());
                }
                else {
                    // å°†å·¥å…·ç»“æœå‘å›AIæ¨¡å‹ç»§ç»­å¯¹è¯
                    return this.internalStream(
                        new Prompt(toolExecutionResult.conversationHistory(), prompt.getOptions()),
                        response
                    );
                }
            });
        
        // âœ… ä¸å†éœ€è¦ .subscribeOn(Schedulers.boundedElastic())
        // å› ä¸ºï¼š
        // 1. å¦‚æœæ˜¯å¼‚æ­¥å·¥å…·ï¼Œä¸ä¼šé˜»å¡çº¿ç¨‹
        // 2. å¦‚æœæ˜¯åŒæ­¥å·¥å…·ï¼ŒexecuteToolCallsAsyncå†…éƒ¨å·²ç»å¤„ç†äº†çº¿ç¨‹åˆ‡æ¢
        
    }
    else {
        return Flux.just(response);
    }
})
.doOnError(observation::error)
.doFinally(s -> observation.stop())
.contextWrite(ctx -> ctx.put(ObservationThreadLocalAccessor.KEY, observation));
// @formatter:on
```

**å…³é”®å˜åŒ–**ï¼š
1. âŒ åˆ é™¤ï¼š`.subscribeOn(Schedulers.boundedElastic())`
2. âŒ åˆ é™¤ï¼š`Flux.deferContextual(ctx -> { ... })`
3. âœ… æ›¿æ¢ä¸ºï¼š`toolCallingManager.executeToolCallsAsync()`
4. âœ… ç®€åŒ–äº†ä»£ç é€»è¾‘

---

### **3.2 æ‰¹é‡æ›´æ–°å…¶ä»–10ä¸ªæ¨¡å‹**

éœ€è¦æ›´æ–°çš„æ–‡ä»¶åˆ—è¡¨ï¼š

```
1. âœ… models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiChatModel.java
2. â³ models/spring-ai-azure-openai/src/main/java/org/springframework/ai/azure/openai/AzureOpenAiChatModel.java
3. â³ models/spring-ai-anthropic/src/main/java/org/springframework/ai/anthropic/AnthropicChatModel.java
4. â³ models/spring-ai-google-genai/src/main/java/org/springframework/ai/google/genai/GoogleGenAiChatModel.java
5. â³ models/spring-ai-vertex-ai-gemini/src/main/java/org/springframework/ai/vertexai/gemini/VertexAiGeminiChatModel.java
6. â³ models/spring-ai-zhipuai/src/main/java/org/springframework/ai/zhipuai/ZhiPuAiChatModel.java
7. â³ models/spring-ai-deepseek/src/main/java/org/springframework/ai/deepseek/DeepSeekChatModel.java
8. â³ models/spring-ai-mistral-ai/src/main/java/org/springframework/ai/mistralai/MistralAiChatModel.java
9. â³ models/spring-ai-minimax/src/main/java/org/springframework/ai/minimax/MiniMaxChatModel.java
10. â³ models/spring-ai-ollama/src/main/java/org/springframework/ai/ollama/OllamaChatModel.java
11. â³ models/spring-ai-bedrock-converse/src/main/java/org/springframework/ai/bedrock/converse/BedrockProxyChatModel.java
```

**æ¯ä¸ªæ–‡ä»¶çš„ä¿®æ”¹æ¨¡å¼ç›¸åŒ**ï¼Œä½¿ç”¨è„šæœ¬æˆ–IDEçš„å¤šæ–‡ä»¶æ›¿æ¢åŠŸèƒ½ã€‚

---

## ğŸ“ **Phase 4: æµ‹è¯•å’Œæ–‡æ¡£**

### **4.1 å•å…ƒæµ‹è¯•**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/test/java/org/springframework/ai/tool/AsyncToolCallbackTest.java`

```java
package org.springframework.ai.tool;

import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import org.springframework.ai.chat.model.ToolContext;
import org.springframework.ai.tool.definition.ToolDefinition;
import org.springframework.ai.tool.metadata.ToolMetadata;

import java.time.Duration;

import static org.assertj.core.api.Assertions.assertThat;

class AsyncToolCallbackTest {

    @Test
    void testAsyncToolCallback() {
        AsyncToolCallback tool = new TestAsyncTool();

        // æµ‹è¯•å¼‚æ­¥è°ƒç”¨
        Mono<String> resultMono = tool.callAsync("{\"input\":\"test\"}", null);
        
        StepVerifier.create(resultMono)
            .expectNext("async result: test")
            .verifyComplete();
    }

    @Test
    void testSyncFallback() {
        AsyncToolCallback tool = new TestAsyncTool();

        // æµ‹è¯•åŒæ­¥é™çº§ï¼ˆåº”è¯¥é˜»å¡ç­‰å¾…ï¼‰
        String result = tool.call("{\"input\":\"test\"}", null);
        
        assertThat(result).isEqualTo("async result: test");
    }

    @Test
    void testSupportsAsync() {
        AsyncToolCallback tool = new TestAsyncTool();
        assertThat(tool.supportsAsync()).isTrue();
    }

    @Test
    void testTimeout() {
        AsyncToolCallback tool = new SlowAsyncTool();

        Mono<String> resultMono = tool.callAsync("{\"input\":\"test\"}", null)
            .timeout(Duration.ofMillis(100));

        StepVerifier.create(resultMono)
            .expectError(java.util.concurrent.TimeoutException.class)
            .verify();
    }

    // æµ‹è¯•å·¥å…·å®ç°
    static class TestAsyncTool implements AsyncToolCallback {

        @Override
        public Mono<String> callAsync(String toolInput, ToolContext context) {
            return Mono.just("async result: " + parseInput(toolInput));
        }

        @Override
        public ToolDefinition getToolDefinition() {
            return ToolDefinition.builder()
                .name("test_tool")
                .description("Test async tool")
                .build();
        }

        private String parseInput(String input) {
            return input.replace("{\"input\":\"", "").replace("\"}", "");
        }
    }

    static class SlowAsyncTool implements AsyncToolCallback {

        @Override
        public Mono<String> callAsync(String toolInput, ToolContext context) {
            return Mono.delay(Duration.ofSeconds(5))
                .map(i -> "slow result");
        }

        @Override
        public ToolDefinition getToolDefinition() {
            return ToolDefinition.builder()
                .name("slow_tool")
                .description("Slow async tool")
                .build();
        }
    }
}
```

---

### **4.2 é›†æˆæµ‹è¯•**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/test/java/org/springframework/ai/model/tool/AsyncToolCallingManagerIT.java`

```java
package org.springframework.ai.model.tool;

import org.junit.jupiter.api.Test;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatResponse;
import org.springframework.ai.chat.model.Generation;
import org.springframework.ai.chat.model.ToolContext;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.tool.AsyncToolCallback;
import org.springframework.ai.tool.ToolCallback;
import org.springframework.ai.tool.definition.ToolDefinition;
import org.springframework.ai.tool.resolution.SimpleToolCallbackResolver;

import java.time.Duration;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;

class AsyncToolCallingManagerIT {

    @Test
    void testAsyncToolExecution() {
        // åˆ›å»ºå¼‚æ­¥å·¥å…·
        AsyncToolCallback asyncTool = new TestAsyncTool("async_tool", Duration.ofMillis(100));

        // åˆ›å»ºToolCallingManager
        ToolCallingManager manager = DefaultToolCallingManager.builder()
            .toolCallbackResolver(new SimpleToolCallbackResolver(List.of(asyncTool)))
            .build();

        // æ¨¡æ‹ŸAIå“åº”ï¼ˆåŒ…å«å·¥å…·è°ƒç”¨ï¼‰
        ChatResponse chatResponse = createChatResponseWithToolCall("async_tool", "{\"input\":\"test\"}");
        Prompt prompt = new Prompt(List.of(new UserMessage("test")));

        // å¼‚æ­¥æ‰§è¡Œå·¥å…·
        Mono<ToolExecutionResult> resultMono = manager.executeToolCallsAsync(prompt, chatResponse);

        StepVerifier.create(resultMono)
            .assertNext(result -> {
                assertThat(result.conversationHistory()).hasSize(3);
                assertThat(result.returnDirect()).isFalse();
            })
            .verifyComplete();
    }

    @Test
    void testMultipleAsyncToolsInParallel() {
        // åˆ›å»ºå¤šä¸ªå¼‚æ­¥å·¥å…·
        AtomicInteger counter = new AtomicInteger(0);
        AsyncToolCallback tool1 = new CountingAsyncTool("tool1", Duration.ofMillis(100), counter);
        AsyncToolCallback tool2 = new CountingAsyncTool("tool2", Duration.ofMillis(100), counter);

        ToolCallingManager manager = DefaultToolCallingManager.builder()
            .toolCallbackResolver(new SimpleToolCallbackResolver(List.of(tool1, tool2)))
            .build();

        // æ¨¡æ‹Ÿå¤šä¸ªå·¥å…·è°ƒç”¨
        ChatResponse chatResponse = createChatResponseWithMultipleToolCalls(
            List.of("tool1", "tool2"),
            List.of("{\"input\":\"test1\"}", "{\"input\":\"test2\"}")
        );
        Prompt prompt = new Prompt(List.of(new UserMessage("test")));

        // æµ‹è¯•å¹¶è¡Œæ‰§è¡Œ
        long startTime = System.currentTimeMillis();
        
        Mono<ToolExecutionResult> resultMono = manager.executeToolCallsAsync(prompt, chatResponse);
        
        StepVerifier.create(resultMono)
            .assertNext(result -> {
                long duration = System.currentTimeMillis() - startTime;
                
                // å¹¶è¡Œæ‰§è¡Œåº”è¯¥åœ¨150mså†…å®Œæˆï¼ˆè€Œä¸æ˜¯200msï¼‰
                assertThat(duration).isLessThan(150);
                assertThat(counter.get()).isEqualTo(2);
            })
            .verifyComplete();
    }

    @Test
    void testSyncToolFallback() {
        // åˆ›å»ºåŒæ­¥å·¥å…·
        ToolCallback syncTool = new TestSyncTool("sync_tool");

        ToolCallingManager manager = DefaultToolCallingManager.builder()
            .toolCallbackResolver(new SimpleToolCallbackResolver(List.of(syncTool)))
            .build();

        ChatResponse chatResponse = createChatResponseWithToolCall("sync_tool", "{\"input\":\"test\"}");
        Prompt prompt = new Prompt(List.of(new UserMessage("test")));

        // æµ‹è¯•é™çº§åˆ°åŒæ­¥æ‰§è¡Œ
        Mono<ToolExecutionResult> resultMono = manager.executeToolCallsAsync(prompt, chatResponse);

        StepVerifier.create(resultMono)
            .assertNext(result -> {
                assertThat(result.conversationHistory()).hasSize(3);
            })
            .verifyComplete();
    }

    // è¾…åŠ©æ–¹æ³•å’Œæµ‹è¯•å·¥å…·...
    // (çœç•¥è¯¦ç»†å®ç°)
}
```

---

### **4.3 æ€§èƒ½åŸºå‡†æµ‹è¯•**

**æ–‡ä»¶**ï¼š`spring-ai-model/src/test/java/org/springframework/ai/model/tool/ToolExecutionBenchmark.java`

```java
package org.springframework.ai.model.tool;

import org.openjdk.jmh.annotations.*;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.concurrent.TimeUnit;

/**
 * JMHæ€§èƒ½åŸºå‡†æµ‹è¯•
 * 
 * è¿è¡Œï¼šmvn clean test -Pbenchmark
 */
@State(Scope.Benchmark)
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@Warmup(iterations = 3, time = 1)
@Measurement(iterations = 5, time = 1)
@Fork(1)
public class ToolExecutionBenchmark {

    private ToolCallingManager manager;
    private ChatResponse syncToolResponse;
    private ChatResponse asyncToolResponse;
    private Prompt prompt;

    @Setup
    public void setup() {
        // è®¾ç½®åŒæ­¥å’Œå¼‚æ­¥å·¥å…·
        // ...
    }

    @Benchmark
    public ToolExecutionResult syncToolExecution() {
        return manager.executeToolCalls(prompt, syncToolResponse);
    }

    @Benchmark
    public ToolExecutionResult asyncToolExecution() {
        return manager.executeToolCallsAsync(prompt, asyncToolResponse).block();
    }

    /**
     * é¢„æœŸç»“æœï¼š
     * - åŒæ­¥æ¨¡å¼ï¼š~100-200 ops/sec
     * - å¼‚æ­¥æ¨¡å¼ï¼š~1000-2000 ops/sec
     * - æ€§èƒ½æå‡ï¼š5-10å€
     */
}
```

---

### **4.4 è¿ç§»æŒ‡å—**

**æ–‡ä»¶**ï¼š`spring-ai-docs/src/main/antora/modules/ROOT/pages/guides/async-tools-migration.adoc`

```asciidoc
= å¼‚æ­¥å·¥å…·è¿ç§»æŒ‡å—
:page-section: guides
:page-aliases: async-tools, performance-optimization

æœ¬æŒ‡å—å¸®åŠ©ä½ å°†åŒæ­¥å·¥å…·è¿ç§»åˆ°å¼‚æ­¥å·¥å…·ï¼Œä»¥è·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚

== ä¸ºä»€ä¹ˆè¦è¿ç§»ï¼Ÿ

[options="header"]
|===
| åœºæ™¯ | åŒæ­¥å·¥å…· | å¼‚æ­¥å·¥å…· | æ€§èƒ½æå‡
| 10å¹¶å‘è¯·æ±‚ | å¹³å‡å»¶è¿Ÿ2ç§’ | å¹³å‡å»¶è¿Ÿ2ç§’ | 0%
| 100å¹¶å‘è¯·æ±‚ | å¹³å‡å»¶è¿Ÿ4ç§’ | å¹³å‡å»¶è¿Ÿ2ç§’ | 50%
| 500å¹¶å‘è¯·æ±‚ | å¹³å‡å»¶è¿Ÿ12ç§’ | å¹³å‡å»¶è¿Ÿ2ç§’ | 83%
|===

== è¿ç§»æ­¥éª¤

=== 1. è¯†åˆ«éœ€è¦è¿ç§»çš„å·¥å…·

ä¼˜å…ˆè¿ç§»ä»¥ä¸‹ç±»å‹çš„å·¥å…·ï¼š

* âœ… è°ƒç”¨å¤–éƒ¨HTTP API
* âœ… æŸ¥è¯¢æ•°æ®åº“
* âœ… è¯»å†™æ–‡ä»¶
* âœ… æ‰§è¡Œæ—¶é—´>1ç§’çš„æ“ä½œ

*ä¸éœ€è¦è¿ç§»*çš„å·¥å…·ï¼š

* âŒ çº¯è®¡ç®—ä»»åŠ¡ï¼ˆ<100msï¼‰
* âŒ ç®€å•çš„å­—ç¬¦ä¸²å¤„ç†
* âŒ å†…å­˜æ“ä½œ

=== 2. æ·»åŠ ä¾èµ–

ç¡®ä¿ä½ çš„é¡¹ç›®åŒ…å«Reactorä¾èµ–ï¼š

[source,xml]
----
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
</dependency>
----

=== 3. ä¿®æ”¹å·¥å…·å®ç°

==== ç¤ºä¾‹1ï¼šHTTPè°ƒç”¨å·¥å…·

*ä¹‹å‰ï¼ˆåŒæ­¥ï¼‰ï¼š*

[source,java]
----
@Component
public class WeatherTool implements ToolCallback {
    
    private final RestTemplate restTemplate;
    
    @Override
    public String call(String toolInput, ToolContext context) {
        WeatherRequest request = parseInput(toolInput);
        
        // âŒ åŒæ­¥é˜»å¡è°ƒç”¨
        return restTemplate.getForObject(
            "https://api.weather.com/weather?city=" + request.getCity(),
            String.class
        );
    }
    
    @Override
    public ToolDefinition getToolDefinition() {
        return ToolDefinition.builder()
            .name("get_weather")
            .description("è·å–åŸå¸‚å¤©æ°”")
            .build();
    }
}
----

*ä¹‹åï¼ˆå¼‚æ­¥ï¼‰ï¼š*

[source,java]
----
@Component
public class WeatherTool implements AsyncToolCallback {
    
    private final WebClient webClient;
    
    public WeatherTool(WebClient.Builder builder) {
        this.webClient = builder
            .baseUrl("https://api.weather.com")
            .build();
    }
    
    @Override
    public Mono<String> callAsync(String toolInput, ToolContext context) {
        WeatherRequest request = parseInput(toolInput);
        
        // âœ… å¼‚æ­¥éé˜»å¡è°ƒç”¨
        return webClient.get()
            .uri("/weather?city={city}", request.getCity())
            .retrieve()
            .bodyToMono(String.class)
            .timeout(Duration.ofSeconds(5))
            .onErrorResume(ex -> Mono.just("Error: " + ex.getMessage()));
    }
    
    @Override
    public ToolDefinition getToolDefinition() {
        return ToolDefinition.builder()
            .name("get_weather")
            .description("è·å–åŸå¸‚å¤©æ°”")
            .build();
    }
}
----

*å…³é”®å˜åŒ–ï¼š*

1. âœ… `ToolCallback` â†’ `AsyncToolCallback`
2. âœ… `String call()` â†’ `Mono<String> callAsync()`
3. âœ… `RestTemplate` â†’ `WebClient`
4. âœ… æ·»åŠ è¶…æ—¶å’Œé”™è¯¯å¤„ç†

== æœ€ä½³å®è·µ

=== 1. è®¾ç½®åˆç†çš„è¶…æ—¶

[source,java]
----
return webClient.get()
    .uri("...")
    .retrieve()
    .bodyToMono(String.class)
    .timeout(Duration.ofSeconds(10));  // â† å¿…éœ€ï¼
----

=== 2. ä¼˜é›…çš„é”™è¯¯å¤„ç†

[source,java]
----
return webClient.get()
    .uri("...")
    .retrieve()
    .bodyToMono(String.class)
    .onErrorResume(TimeoutException.class, ex -> 
        Mono.just("è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
    )
    .onErrorResume(ex -> 
        Mono.just("è·å–æ•°æ®å¤±è´¥: " + ex.getMessage())
    );
----

=== 3. é‡è¯•æœºåˆ¶

[source,java]
----
return webClient.get()
    .uri("...")
    .retrieve()
    .bodyToMono(String.class)
    .retry(3)  // å¤±è´¥é‡è¯•3æ¬¡
    .timeout(Duration.ofSeconds(10));
----

== å¸¸è§é—®é¢˜

=== Q: å¿…é¡»å…¨éƒ¨è¿ç§»å—ï¼Ÿ

A: ä¸æ˜¯ï¼å¼‚æ­¥å·¥å…·æ˜¯å¯é€‰çš„ã€‚æ¡†æ¶ä¼šè‡ªåŠ¨æ£€æµ‹ï¼š

* å¦‚æœæ˜¯`AsyncToolCallback`ï¼šä½¿ç”¨å¼‚æ­¥æ‰§è¡Œ
* å¦‚æœæ˜¯`ToolCallback`ï¼šä½¿ç”¨åŒæ­¥æ‰§è¡Œï¼ˆboundedElasticï¼‰

=== Q: è¿ç§»åæ€§èƒ½æå‡å¤šå°‘ï¼Ÿ

A: å–å†³äºå¹¶å‘é‡å’Œå·¥å…·æ‰§è¡Œæ—¶é—´ï¼š

* ä½å¹¶å‘(<50)ï¼šæå‡ä¸æ˜æ˜¾
* ä¸­å¹¶å‘(50-200)ï¼šæå‡50-80%
* é«˜å¹¶å‘(>200)ï¼šæå‡80-95%

=== Q: å¦‚ä½•éªŒè¯è¿ç§»æˆåŠŸï¼Ÿ

A: æ£€æŸ¥æ—¥å¿—ï¼š

[source]
----
DEBUG o.s.ai.model.tool.DefaultToolCallingManager - 
    Executing tool asynchronously: get_weather
----

å¦‚æœçœ‹åˆ°"asynchronously"ï¼Œè¯´æ˜å¼‚æ­¥å·¥ä½œæ­£å¸¸ã€‚

== ä¸‹ä¸€æ­¥

* link:async-tools-api.html[å¼‚æ­¥å·¥å…·APIæ–‡æ¡£]
* link:performance-tuning.html[æ€§èƒ½è°ƒä¼˜æŒ‡å—]
* link:reactive-programming.html[å“åº”å¼ç¼–ç¨‹å…¥é—¨]
```

---

## ğŸ“Š **Phase 5: éªŒæ”¶æ ‡å‡†**

### **5.1 åŠŸèƒ½éªŒæ”¶**

- [ ] AsyncToolCallbackæ¥å£å®ç°å®Œæˆ
- [ ] ToolCallingManager.executeToolCallsAsync()å®ç°å®Œæˆ
- [ ] 11ä¸ªChatModelå…¨éƒ¨æ›´æ–°å®Œæˆ
- [ ] å‘åå…¼å®¹æµ‹è¯•é€šè¿‡ï¼ˆæ—§ä»£ç æ— éœ€ä¿®æ”¹ï¼‰
- [ ] å¼‚æ­¥å·¥å…·æ­£å¸¸å·¥ä½œ
- [ ] åŒæ­¥å·¥å…·é™çº§æ­£å¸¸å·¥ä½œ

### **5.2 æ€§èƒ½éªŒæ”¶**

- [ ] 100å¹¶å‘åœºæ™¯ï¼šæ€§èƒ½æå‡>50%
- [ ] 500å¹¶å‘åœºæ™¯ï¼šæ€§èƒ½æå‡>80%
- [ ] æ— å†…å­˜æ³„æ¼
- [ ] æ— çº¿ç¨‹æ³„æ¼
- [ ] CPUä½¿ç”¨ç‡æ­£å¸¸

### **5.3 æ–‡æ¡£éªŒæ”¶**

- [ ] APIæ–‡æ¡£å®Œæ•´
- [ ] è¿ç§»æŒ‡å—å®Œæ•´
- [ ] ç¤ºä¾‹ä»£ç å¯è¿è¡Œ
- [ ] å¸¸è§é—®é¢˜è§£ç­”å®Œæ•´

---

## ğŸ› ï¸ **å¼€å‘å·¥å…·å’Œè„šæœ¬**

### **æ‰¹é‡ä¿®æ”¹è„šæœ¬ï¼ˆBashï¼‰**

```bash
#!/bin/bash

# æ‰¹é‡æ›´æ–°11ä¸ªæ¨¡å‹çš„è„šæœ¬
# ç”¨æ³•: ./update-models.sh

MODELS=(
    "models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiChatModel.java"
    "models/spring-ai-azure-openai/src/main/java/org/springframework/ai/azure/openai/AzureOpenAiChatModel.java"
    "models/spring-ai-anthropic/src/main/java/org/springframework/ai/anthropic/AnthropicChatModel.java"
    "models/spring-ai-google-genai/src/main/java/org/springframework/ai/google/genai/GoogleGenAiChatModel.java"
    "models/spring-ai-vertex-ai-gemini/src/main/java/org/springframework/ai/vertexai/gemini/VertexAiGeminiChatModel.java"
    "models/spring-ai-zhipuai/src/main/java/org/springframework/ai/zhipuai/ZhiPuAiChatModel.java"
    "models/spring-ai-deepseek/src/main/java/org/springframework/ai/deepseek/DeepSeekChatModel.java"
    "models/spring-ai-mistral-ai/src/main/java/org/springframework/ai/mistralai/MistralAiChatModel.java"
    "models/spring-ai-minimax/src/main/java/org/springframework/ai/minimax/MiniMaxChatModel.java"
    "models/spring-ai-ollama/src/main/java/org/springframework/ai/ollama/OllamaChatModel.java"
    "models/spring-ai-bedrock-converse/src/main/java/org/springframework/ai/bedrock/converse/BedrockProxyChatModel.java"
)

for model in "${MODELS[@]}"; do
    echo "Processing: $model"
    
    # å¤‡ä»½åŸæ–‡ä»¶
    cp "$model" "$model.bak"
    
    # TODO: æ·»åŠ å®é™…çš„sed/awkå‘½ä»¤è¿›è¡Œæ›¿æ¢
    # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…ä»£ç ç»“æ„è°ƒæ•´
    
    echo "âœ… Updated: $model"
done

echo "All models updated!"
```

---

## ğŸ“ **æ€»ç»“**

### **å…³é”®å†³ç­–ç‚¹**

1. **å‘åå…¼å®¹æ€§**ï¼šæœ€é«˜ä¼˜å…ˆçº§
2. **æ€§èƒ½æå‡**ï¼š5-10å€
3. **å®æ–½éš¾åº¦**ï¼šä¸­ç­‰ï¼ˆ6-10å‘¨ï¼‰
4. **é£é™©**ï¼šä½ï¼ˆæ¸è¿›å¼ï¼Œå¯å›æ»šï¼‰

### **æˆåŠŸå› ç´ **

1. âœ… æ¸…æ™°çš„æ¥å£è®¾è®¡
2. âœ… å®Œå–„çš„æµ‹è¯•è¦†ç›–
3. âœ… è¯¦ç»†çš„è¿ç§»æŒ‡å—
4. âœ… å……åˆ†çš„æ€§èƒ½éªŒè¯

### **ä¸‹ä¸€æ­¥è¡ŒåŠ¨**

1. åˆ›å»ºGitHub Issue/PR
2. å®æ–½Phase 1ï¼ˆæ ¸å¿ƒæ¥å£ï¼‰
3. å†…éƒ¨æµ‹è¯•å’Œreview
4. å®æ–½Phase 2-3
5. Betaæµ‹è¯•
6. æ­£å¼å‘å¸ƒ

---

å¸Œæœ›è¿™ä¸ªè¯¦ç»†çš„å®æ–½æŒ‡å—å¯¹ä½ æœ‰å¸®åŠ©ï¼ğŸ‰

