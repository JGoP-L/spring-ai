# æµå¼å·¥å…·è°ƒç”¨é—®é¢˜æ·±åº¦åˆ†æ

## ğŸ”´ **é—®é¢˜æ¦‚è¿°**

Spring AIçš„æ‰€æœ‰11ä¸ªæ”¯æŒFunction Callingçš„æ¨¡å‹éƒ½å­˜åœ¨åŒä¸€ä¸ªæ€§èƒ½é—®é¢˜ï¼š
```java
// FIXME: bounded elastic needs to be used since tool calling
//  is currently only synchronous
.subscribeOn(Schedulers.boundedElastic());
```

è¿™ä¸æ˜¯ä»£ç é”™è¯¯ï¼Œè€Œæ˜¯**æ¶æ„è®¾è®¡çš„å¿…ç„¶å¦¥å**ã€‚

---

## ğŸ¯ **é—®é¢˜æ ¹æœ¬åŸå› **

### **æ ¸å¿ƒçŸ›ç›¾**ï¼šå¼‚æ­¥æµ vs åŒæ­¥å·¥å…·

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   å¼‚æ­¥ä¸–ç•Œ (Reactive/éé˜»å¡)              â”‚
â”‚   - AIæ¨¡å‹çš„æµå¼å“åº”æ˜¯å¼‚æ­¥çš„              â”‚
â”‚   - ä½¿ç”¨Flux<ChatResponse>               â”‚
â”‚   - ä¸é˜»å¡çº¿ç¨‹                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
         é‡åˆ°Tool Callè¯·æ±‚
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   åŒæ­¥ä¸–ç•Œ (é˜»å¡)                         â”‚
â”‚   - ç”¨æˆ·çš„å·¥å…·å‡½æ•°æ˜¯åŒæ­¥çš„                â”‚
â”‚   - String call(String arguments)       â”‚
â”‚   - ä¼šé˜»å¡çº¿ç¨‹                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“– **è¯¦ç»†æŠ€æœ¯åˆ†æ**

### **1. æµå¼å“åº”çš„å·¥ä½œåŸç†**

```java
// ç”¨æˆ·è°ƒç”¨æµå¼API
Flux<ChatResponse> responses = chatModel.stream(prompt);

// å¹•åå‘ç”Ÿçš„äº‹æƒ…
WebClient.create("https://api.openai.com")
    .post()
    .bodyValue(request)
    .retrieve()
    .bodyToFlux(ChatCompletionChunk.class)  // â† éé˜»å¡çš„æµå¼æ¥æ”¶
    .map(chunk -> toChatResponse(chunk));   // â† åœ¨I/Oçº¿ç¨‹ä¸Šå¤„ç†
```

**ç‰¹ç‚¹**ï¼š
- âœ… **éé˜»å¡**ï¼šä¸å ç”¨çº¿ç¨‹ç­‰å¾…å“åº”
- âœ… **èƒŒå‹æ”¯æŒ**ï¼šå¯ä»¥æ§åˆ¶æ•°æ®æµé€Ÿ
- âœ… **é«˜å¹¶å‘**ï¼šä¸€ä¸ªçº¿ç¨‹å¯ä»¥å¤„ç†æˆåƒä¸Šä¸‡ä¸ªè¯·æ±‚

---

### **2. å·¥å…·è°ƒç”¨çš„å·¥ä½œåŸç†**

```java
// AIæ¨¡å‹è¿”å›ï¼š"æˆ‘éœ€è¦è°ƒç”¨get_weatherå‡½æ•°"
ChatResponse response = {
    toolCalls: [
        { name: "get_weather", arguments: "{\"city\":\"åŒ—äº¬\"}" }
    ]
}

// Spring AIéœ€è¦æ‰§è¡Œè¿™ä¸ªå·¥å…·
ToolCallback callback = toolCallbackResolver.resolve("get_weather");
String result = callback.call("{\"city\":\"åŒ—äº¬\"}");  // â† åŒæ­¥é˜»å¡ï¼

// å¦‚æœget_weatherå‡½æ•°éœ€è¦è°ƒç”¨å¤–éƒ¨API
public String getWeather(String city) {
    // è¿™é‡Œå¯èƒ½è°ƒç”¨HTTP APIã€æŸ¥è¯¢æ•°æ®åº“ç­‰
    // è¿™äº›æ“ä½œæ˜¯é˜»å¡çš„ï¼
    return httpClient.get("https://api.weather.com?city=" + city);  // é˜»å¡5ç§’
}
```

**ç‰¹ç‚¹**ï¼š
- âŒ **é˜»å¡**ï¼šå¿…é¡»ç­‰å¾…å·¥å…·æ‰§è¡Œå®Œæˆ
- âŒ **åŒæ­¥**ï¼šä¸€æ¬¡åªèƒ½æ‰§è¡Œä¸€ä¸ªå·¥å…·
- âŒ **å ç”¨çº¿ç¨‹**ï¼šæ‰§è¡ŒæœŸé—´çº¿ç¨‹è¢«å ç”¨

---

### **3. é—®é¢˜çš„å…·ä½“ä»£ç ä½ç½®**

#### **æµå¼æ¨¡å‹çš„å®ç°ï¼ˆæ‰€æœ‰11ä¸ªæ¨¡å‹éƒ½ç±»ä¼¼ï¼‰**

```java
// OpenAiChatModel.java:365-389
Flux<ChatResponse> flux = chatResponse.flatMap(response -> {
    if (this.toolExecutionEligibilityPredicate.isToolExecutionRequired(prompt.getOptions(), response)) {
        // ğŸ”´ é—®é¢˜å°±åœ¨è¿™é‡Œï¼
        return Flux.deferContextual(ctx -> {
            ToolExecutionResult toolExecutionResult;
            try {
                ToolCallReactiveContextHolder.setContext(ctx);
                
                // âš ï¸ è¿™æ˜¯ä¸€ä¸ªåŒæ­¥é˜»å¡è°ƒç”¨ï¼
                toolExecutionResult = this.toolCallingManager.executeToolCalls(prompt, response);
                //                     â†‘
                //                è¿™é‡Œä¼šé˜»å¡çº¿ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰å·¥å…·æ‰§è¡Œå®Œæˆ
                
            }
            finally {
                ToolCallReactiveContextHolder.clearContext();
            }
            
            if (toolExecutionResult.returnDirect()) {
                return Flux.just(ChatResponse.builder().from(response)
                    .generations(ToolExecutionResult.buildGenerations(toolExecutionResult))
                    .build());
            }
            else {
                // å°†å·¥å…·æ‰§è¡Œç»“æœå‘å›AIæ¨¡å‹ï¼Œç»§ç»­å¯¹è¯
                return this.internalStream(new Prompt(toolExecutionResult.conversationHistory(), prompt.getOptions()),
                        response);
            }
        }).subscribeOn(Schedulers.boundedElastic());  // â† è¢«è¿«ä½¿ç”¨æœ‰é™çº¿ç¨‹æ± 
        //       â†‘
        //       å¿…é¡»åˆ‡æ¢åˆ°ç‹¬ç«‹çº¿ç¨‹æ± ï¼Œå¦åˆ™ä¼šé˜»å¡I/Oçº¿ç¨‹
    }
    else {
        return Flux.just(response);
    }
})
```

---

#### **å·¥å…·è°ƒç”¨ç®¡ç†å™¨çš„å®ç°**

```java
// DefaultToolCallingManager.java:126-153
@Override
public ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse) {
    // ...
    
    // éå†æ‰€æœ‰å·¥å…·è°ƒç”¨
    for (AssistantMessage.ToolCall toolCall : assistantMessage.getToolCalls()) {
        String toolName = toolCall.name();
        String toolInputArguments = toolCall.arguments();
        
        ToolCallback toolCallback = toolCallbacks.stream()
            .filter(tool -> toolName.equals(tool.getToolDefinition().name()))
            .findFirst()
            .orElseGet(() -> this.toolCallbackResolver.resolve(toolName));
        
        // âš ï¸ åŒæ­¥è°ƒç”¨ç”¨æˆ·çš„å·¥å…·å‡½æ•°
        String toolCallResult = toolCallback.call(finalToolInputArguments, toolContext);
        //                       â†‘
        //                   è¿™é‡Œä¼šé˜»å¡ï¼Œå¯èƒ½éœ€è¦å‡ ç§’ç”šè‡³å‡ åç§’
        
        toolResponses.add(new ToolResponseMessage.ToolResponse(
            toolCall.id(), toolName, toolCallResult
        ));
    }
    
    return new ToolExecutionResult(...);
}
```

---

### **4. ä¸ºä»€ä¹ˆå¿…é¡»ä½¿ç”¨ `boundedElastic`ï¼Ÿ**

#### **é€‰é¡¹1ï¼šä¸åˆ‡æ¢çº¿ç¨‹ï¼ˆé”™è¯¯ï¼‰**

```java
// âŒ å¦‚æœç›´æ¥åœ¨I/Oçº¿ç¨‹ä¸Šæ‰§è¡Œå·¥å…·
Flux<ChatResponse> flux = chatResponse.flatMap(response -> {
    // ç›´æ¥åœ¨å½“å‰çº¿ç¨‹ï¼ˆI/Oçº¿ç¨‹ï¼‰æ‰§è¡Œ
    ToolExecutionResult result = this.toolCallingManager.executeToolCalls(prompt, response);
    // ...
});
```

**åæœ**ï¼š
- ğŸ’¥ **é˜»å¡I/Oçº¿ç¨‹**ï¼šNetty/Reactorçš„I/Oçº¿ç¨‹è¢«é˜»å¡
- ğŸ’¥ **é›ªå´©æ•ˆåº”**ï¼šæ‰€æœ‰å¹¶å‘è¯·æ±‚éƒ½ä¼šå—å½±å“
- ğŸ’¥ **ç³»ç»Ÿç˜«ç—ª**ï¼šI/Oçº¿ç¨‹æ± è€—å°½ï¼Œæ— æ³•æ¥æ”¶æ–°è¯·æ±‚

```
æ—¶é—´çº¿ï¼š
T=0s   : 100ä¸ªå¹¶å‘è¯·æ±‚åˆ°è¾¾
T=0.1s : I/Oçº¿ç¨‹æ± (8ä¸ªçº¿ç¨‹)å…¨éƒ¨è¢«å·¥å…·è°ƒç”¨é˜»å¡
T=0.2s : æ–°è¯·æ±‚æ— æ³•å¤„ç†ï¼Œå¼€å§‹æ’é˜Ÿ
T=5s   : å·¥å…·è°ƒç”¨å®Œæˆï¼Œçº¿ç¨‹é‡Šæ”¾
T=5s   : ç§¯å‹çš„è¯·æ±‚å¼€å§‹å¤„ç†
         â†‘
        å¤ªæ™šäº†ï¼ç”¨æˆ·å·²ç»è¶…æ—¶
```

---

#### **é€‰é¡¹2ï¼šä½¿ç”¨ `Schedulers.parallel()`ï¼ˆä¸å¤Ÿå¥½ï¼‰**

```java
// ğŸ”¶ ä½¿ç”¨parallelè°ƒåº¦å™¨
.subscribeOn(Schedulers.parallel());
```

**é—®é¢˜**ï¼š
- `parallel()` æ˜¯ä¸º**CPUå¯†é›†å‹**ä»»åŠ¡è®¾è®¡çš„
- çº¿ç¨‹æ•° = CPUæ ¸å¿ƒæ•°ï¼ˆé€šå¸¸8-16ä¸ªï¼‰
- å·¥å…·è°ƒç”¨æ˜¯**I/Oå¯†é›†å‹**ä»»åŠ¡ï¼ˆç½‘ç»œè¯·æ±‚ã€æ•°æ®åº“æŸ¥è¯¢ï¼‰
- ä¼šå¿«é€Ÿè€—å°½çº¿ç¨‹æ± 

---

#### **é€‰é¡¹3ï¼šä½¿ç”¨ `Schedulers.boundedElastic()`ï¼ˆå½“å‰æ–¹æ¡ˆï¼‰**

```java
// âœ… ä½¿ç”¨boundedElasticè°ƒåº¦å™¨
.subscribeOn(Schedulers.boundedElastic());
```

**ç‰¹ç‚¹**ï¼š
- âœ… ä¸º**é˜»å¡I/O**ä»»åŠ¡è®¾è®¡
- âœ… å¯ä»¥åˆ›å»ºæ›´å¤šçº¿ç¨‹ï¼ˆé»˜è®¤æœ€å¤š `CPUæ ¸å¿ƒæ•° Ã— 10`ï¼‰
- âœ… çº¿ç¨‹æœ‰è¶…æ—¶å›æ”¶æœºåˆ¶ï¼ˆ60ç§’ï¼‰
- ğŸ”¶ ä½†ä»ç„¶æœ‰ä¸Šé™ï¼ˆä¸æ˜¯æ— é™çš„ï¼‰

**é»˜è®¤é…ç½®**ï¼š
```java
// Schedulers.boundedElastic()çš„é»˜è®¤é…ç½®
int threadCap = Runtime.getRuntime().availableProcessors() * 10;  // ä¾‹å¦‚ï¼š8æ ¸ â†’ 80ä¸ªçº¿ç¨‹
int queuedTaskCap = 100000;  // é˜Ÿåˆ—å®¹é‡
Duration ttl = Duration.ofSeconds(60);  // çº¿ç¨‹ç©ºé—²60ç§’åå›æ”¶
```

---

### **5. é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½ç“¶é¢ˆ**

#### **åœºæ™¯ï¼š100ä¸ªå¹¶å‘ç”¨æˆ·ï¼Œæ¯ä¸ªç”¨æˆ·è§¦å‘3ä¸ªå·¥å…·è°ƒç”¨**

```
å‡è®¾ï¼š
- 8æ ¸CPU
- boundedElasticçº¿ç¨‹æ± ï¼š80ä¸ªçº¿ç¨‹
- æ¯ä¸ªå·¥å…·è°ƒç”¨å¹³å‡è€—æ—¶ï¼š2ç§’

å¹¶å‘æƒ…å†µï¼š
T=0s:   100ä¸ªç”¨æˆ· Ã— 3ä¸ªå·¥å…· = 300ä¸ªå·¥å…·è°ƒç”¨è¯·æ±‚
T=0.1s: 80ä¸ªçº¿ç¨‹å¼€å§‹æ‰§è¡Œå·¥å…·è°ƒç”¨
T=0.1s: å‰©ä½™220ä¸ªå·¥å…·è°ƒç”¨åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…
T=2s:   ç¬¬ä¸€æ‰¹80ä¸ªå·¥å…·è°ƒç”¨å®Œæˆ
T=2.1s: æ¥ä¸‹æ¥80ä¸ªå·¥å…·è°ƒç”¨å¼€å§‹æ‰§è¡Œ
T=2.1s: å‰©ä½™140ä¸ªå·¥å…·è°ƒç”¨ç»§ç»­ç­‰å¾…
T=4s:   ç¬¬äºŒæ‰¹80ä¸ªå·¥å…·è°ƒç”¨å®Œæˆ
T=4.1s: æœ€å60ä¸ªå·¥å…·è°ƒç”¨å¼€å§‹æ‰§è¡Œ
T=6s:   æ‰€æœ‰å·¥å…·è°ƒç”¨å®Œæˆ

ç»“æœï¼š
- å‰80ä¸ªç”¨æˆ·ï¼šå»¶è¿Ÿ ~2ç§’
- ä¸­é—´80ä¸ªç”¨æˆ·ï¼šå»¶è¿Ÿ ~4ç§’
- æœ€å40ä¸ªç”¨æˆ·ï¼šå»¶è¿Ÿ ~6ç§’

å¹³å‡å»¶è¿Ÿï¼š(2s + 4s + 6s) / 3 = 4ç§’
```

**ç°è±¡**ï¼š
- âš ï¸ åœ¨æµé‡é«˜å³°æœŸï¼Œç”¨æˆ·ä¼šæ„Ÿè§‰åˆ°æ˜æ˜¾çš„å»¶è¿Ÿå¢åŠ 
- âš ï¸ å¦‚æœå·¥å…·è°ƒç”¨è€—æ—¶æ›´é•¿ï¼ˆ10ç§’ï¼‰ï¼Œé—®é¢˜ä¼šæ›´ä¸¥é‡

---

## ğŸ¯ **ä¸ºä»€ä¹ˆæ‰€æœ‰11ä¸ªæ¨¡å‹éƒ½æœ‰è¿™ä¸ªé—®é¢˜ï¼Ÿ**

å› ä¸ºå®ƒä»¬éƒ½éµå¾ªç›¸åŒçš„æ¶æ„è®¾è®¡ï¼š

```java
// è¿™æ˜¯Spring AIçš„æ ‡å‡†æ¨¡å¼
Flux<ChatResponse> stream(Prompt prompt) {
    return webClient.post()
        .bodyValue(request)
        .retrieve()
        .bodyToFlux(ResponseChunk.class)  // â† å¼‚æ­¥æµå¼æ¥æ”¶
        .flatMap(chunk -> {
            ChatResponse response = toChatResponse(chunk);
            
            // âš ï¸ å¦‚æœAIæ¨¡å‹è¯·æ±‚å·¥å…·è°ƒç”¨
            if (needToolCalls(response)) {
                // å¿…é¡»åŒæ­¥æ‰§è¡Œå·¥å…·ï¼ˆå› ä¸ºå·¥å…·æ¥å£æ˜¯åŒæ­¥çš„ï¼‰
                return executeToolsInBlockingWay(response);  // â† é˜»å¡æ“ä½œ
            }
            
            return Flux.just(response);
        });
}
```

**å—å½±å“çš„11ä¸ªæ¨¡å‹**ï¼š
1. OpenAI
2. Azure OpenAI
3. Anthropic (Claude)
4. Google Gemini
5. Vertex AI Gemini
6. ZhiPu AI
7. DeepSeek
8. Mistral AI
9. MiniMax
10. Ollama
11. Bedrock Converse

---

## ğŸ’¡ **è§£å†³æ–¹æ¡ˆ**

### **çŸ­æœŸæ–¹æ¡ˆï¼ˆ1-2å‘¨ï¼‰**ï¼šä¼˜åŒ–é…ç½®å’Œç›‘æ§

#### **1. è°ƒæ•´çº¿ç¨‹æ± å¤§å°**

```java
// åœ¨application.ymlä¸­é…ç½®
reactor:
  schedulers:
    bounded-elastic:
      max-threads: 200  # å¢åŠ åˆ°200ä¸ªçº¿ç¨‹ï¼ˆé»˜è®¤80ï¼‰
      queue-size: 200000  # å¢åŠ é˜Ÿåˆ—å¤§å°
      thread-idle-time: 30s  # å‡å°‘çº¿ç¨‹ç©ºé—²æ—¶é—´
```

#### **2. æ·»åŠ æ€§èƒ½ç›‘æ§**

```java
@Bean
public ScheduledExecutorService boundedElasticMonitor() {
    Schedulers.boundedElastic().schedulePeriodically(() -> {
        // ç›‘æ§çº¿ç¨‹æ± ä½¿ç”¨ç‡
        int activeThreads = getBoundedElasticActiveThreads();
        int queueSize = getBoundedElasticQueueSize();
        
        if (activeThreads > 70) {  // è¶…è¿‡70%ä½¿ç”¨ç‡
            logger.warn("BoundedElasticçº¿ç¨‹æ± æ¥è¿‘é¥±å’Œ: {}/{}", activeThreads, 80);
        }
        
        if (queueSize > 50000) {  // é˜Ÿåˆ—è¶…è¿‡50%
            logger.warn("å·¥å…·è°ƒç”¨é˜Ÿåˆ—ç§¯å‹: {}/{}", queueSize, 100000);
        }
    }, 0, 10, TimeUnit.SECONDS);
}
```

#### **3. å®æ–½é™çº§ç­–ç•¥**

```java
@Component
public class AdaptiveToolCallingStrategy {
    private final AtomicInteger concurrentToolCalls = new AtomicInteger(0);
    
    public boolean shouldExecuteTool() {
        int current = concurrentToolCalls.get();
        
        // å¦‚æœå¹¶å‘å·¥å…·è°ƒç”¨è¶…è¿‡100ä¸ªï¼Œæ‹’ç»æ–°çš„å·¥å…·è°ƒç”¨
        if (current > 100) {
            logger.warn("å·¥å…·è°ƒç”¨å¹¶å‘è¿‡é«˜ï¼Œæ‹’ç»æ‰§è¡Œ: {}", current);
            return false;
        }
        
        return true;
    }
    
    public void beforeToolCall() {
        concurrentToolCalls.incrementAndGet();
    }
    
    public void afterToolCall() {
        concurrentToolCalls.decrementAndGet();
    }
}
```

---

### **ä¸­æœŸæ–¹æ¡ˆï¼ˆ1-2ä¸ªæœˆï¼‰**ï¼šæ”¯æŒå¼‚æ­¥å·¥å…·

#### **1. è®¾è®¡å¼‚æ­¥å·¥å…·æ¥å£**

```java
// æ–°æ¥å£ï¼šæ”¯æŒå¼‚æ­¥å·¥å…·è°ƒç”¨
public interface AsyncToolCallback extends ToolCallback {
    /**
     * å¼‚æ­¥è°ƒç”¨å·¥å…·
     * @return Mono<String> å¼‚æ­¥è¿”å›å·¥å…·æ‰§è¡Œç»“æœ
     */
    Mono<String> callAsync(String arguments, ToolContext context);
    
    /**
     * æ˜¯å¦æ”¯æŒå¼‚æ­¥è°ƒç”¨
     */
    default boolean supportsAsync() {
        return true;
    }
}

// ç”¨æˆ·å®ç°å¼‚æ­¥å·¥å…·
@Component
public class AsyncWeatherTool implements AsyncToolCallback {
    
    @Override
    public Mono<String> callAsync(String arguments, ToolContext context) {
        WeatherRequest request = parseArguments(arguments);
        
        // ä½¿ç”¨WebClientè¿›è¡Œéé˜»å¡HTTPè°ƒç”¨
        return webClient.get()
            .uri("https://api.weather.com?city=" + request.getCity())
            .retrieve()
            .bodyToMono(String.class)
            .map(response -> formatWeatherResult(response));
    }
    
    @Override
    public ToolDefinition getToolDefinition() {
        return ToolDefinition.builder()
            .name("get_weather")
            .description("è·å–åŸå¸‚å¤©æ°”")
            .build();
    }
}
```

---

#### **2. ä¿®æ”¹ ToolCallingManager**

```java
public interface ToolCallingManager {
    // ä¿ç•™åŸæœ‰çš„åŒæ­¥æ–¹æ³•ï¼ˆå‘åå…¼å®¹ï¼‰
    ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse);
    
    // ğŸ†• æ–°å¢å¼‚æ­¥æ–¹æ³•
    Mono<ToolExecutionResult> executeToolCallsAsync(Prompt prompt, ChatResponse chatResponse);
}

@Service
public class DefaultToolCallingManager implements ToolCallingManager {
    
    @Override
    public Mono<ToolExecutionResult> executeToolCallsAsync(Prompt prompt, ChatResponse chatResponse) {
        List<AssistantMessage.ToolCall> toolCalls = getToolCalls(chatResponse);
        
        // å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰å·¥å…·è°ƒç”¨
        List<Mono<ToolResponse>> toolResponseMonos = toolCalls.stream()
            .map(toolCall -> executeToolCallAsync(toolCall))
            .toList();
        
        // ç­‰å¾…æ‰€æœ‰å·¥å…·å®Œæˆ
        return Mono.zip(toolResponseMonos, responses -> {
            return buildToolExecutionResult(responses);
        });
    }
    
    private Mono<ToolResponse> executeToolCallAsync(AssistantMessage.ToolCall toolCall) {
        ToolCallback callback = resolveToolCallback(toolCall.name());
        
        // ğŸ” æ£€æŸ¥æ˜¯å¦æ”¯æŒå¼‚æ­¥
        if (callback instanceof AsyncToolCallback asyncCallback && asyncCallback.supportsAsync()) {
            // âœ… ä½¿ç”¨å¼‚æ­¥è°ƒç”¨ï¼ˆéé˜»å¡ï¼‰
            return asyncCallback.callAsync(toolCall.arguments(), toolContext)
                .map(result -> new ToolResponse(toolCall.id(), toolCall.name(), result));
        }
        else {
            // ğŸ”¶ é™çº§åˆ°åŒæ­¥è°ƒç”¨ï¼ˆä»ç„¶éœ€è¦boundedElasticï¼‰
            return Mono.fromCallable(() -> {
                String result = callback.call(toolCall.arguments(), toolContext);
                return new ToolResponse(toolCall.id(), toolCall.name(), result);
            }).subscribeOn(Schedulers.boundedElastic());
        }
    }
}
```

---

#### **3. ä¿®æ”¹æµå¼æ¨¡å‹å®ç°**

```java
// OpenAiChatModel.java
Flux<ChatResponse> flux = chatResponse.flatMap(response -> {
    if (this.toolExecutionEligibilityPredicate.isToolExecutionRequired(prompt.getOptions(), response)) {
        
        // âœ… ä½¿ç”¨å¼‚æ­¥å·¥å…·è°ƒç”¨
        return this.toolCallingManager.executeToolCallsAsync(prompt, response)
            .flatMapMany(toolExecutionResult -> {
                if (toolExecutionResult.returnDirect()) {
                    return Flux.just(ChatResponse.builder().from(response)
                        .generations(ToolExecutionResult.buildGenerations(toolExecutionResult))
                        .build());
                }
                else {
                    return this.internalStream(new Prompt(toolExecutionResult.conversationHistory(), 
                        prompt.getOptions()), response);
                }
            });
        // âœ… ä¸å†éœ€è¦ .subscribeOn(Schedulers.boundedElastic())
        
    }
    else {
        return Flux.just(response);
    }
})
```

---

### **é•¿æœŸæ–¹æ¡ˆï¼ˆ3-6ä¸ªæœˆï¼‰**ï¼šå®Œå…¨å¼‚æ­¥æ¶æ„

#### **1. é‡æ–°è®¾è®¡å·¥å…·è°ƒç”¨æ ‡å‡†**

```java
// å®šä¹‰å·¥å…·è°ƒç”¨çš„ä¸‰ç§æ¨¡å¼
public enum ToolExecutionMode {
    SYNC,      // åŒæ­¥ï¼ˆé˜»å¡ï¼‰
    ASYNC,     // å¼‚æ­¥ï¼ˆéé˜»å¡ï¼‰
    PARALLEL   // å¹¶è¡Œï¼ˆå¤šä¸ªå·¥å…·åŒæ—¶æ‰§è¡Œï¼‰
}

public interface AdvancedToolCallback extends ToolCallback {
    /**
     * è·å–å·¥å…·çš„æ‰§è¡Œæ¨¡å¼
     */
    ToolExecutionMode getExecutionMode();
    
    /**
     * å¼‚æ­¥æ‰§è¡Œï¼ˆè¿”å›Monoï¼‰
     */
    Mono<String> executeAsync(String arguments, ToolContext context);
    
    /**
     * æµå¼æ‰§è¡Œï¼ˆè¿”å›Fluxï¼Œé€‚åˆé•¿æ—¶é—´è¿è¡Œçš„å·¥å…·ï¼‰
     */
    Flux<String> executeStreaming(String arguments, ToolContext context);
}
```

---

#### **2. å®ç°æ™ºèƒ½è°ƒåº¦**

```java
@Service
public class IntelligentToolScheduler {
    
    public Mono<ToolExecutionResult> scheduleToolExecution(
            List<AssistantMessage.ToolCall> toolCalls) {
        
        // 1. åˆ†ç±»å·¥å…·è°ƒç”¨
        Map<ToolExecutionMode, List<ToolCall>> grouped = groupByExecutionMode(toolCalls);
        
        // 2. å¼‚æ­¥å·¥å…·ï¼šç›´æ¥å¹¶è¡Œæ‰§è¡Œï¼ˆä¸é˜»å¡ï¼‰
        Mono<List<ToolResponse>> asyncResults = executeAsyncTools(grouped.get(ASYNC));
        
        // 3. åŒæ­¥å·¥å…·ï¼šä½¿ç”¨ä¸“ç”¨çº¿ç¨‹æ± ï¼ˆéš”ç¦»ï¼‰
        Mono<List<ToolResponse>> syncResults = executeSyncTools(grouped.get(SYNC));
        
        // 4. åˆå¹¶ç»“æœ
        return Mono.zip(asyncResults, syncResults)
            .map(tuple -> combineResults(tuple.getT1(), tuple.getT2()));
    }
    
    private Mono<List<ToolResponse>> executeAsyncTools(List<ToolCall> toolCalls) {
        return Flux.fromIterable(toolCalls)
            .flatMap(toolCall -> {
                AsyncToolCallback callback = (AsyncToolCallback) resolveCallback(toolCall);
                return callback.executeAsync(toolCall.arguments(), toolContext);
            })
            .collectList();
    }
    
    private Mono<List<ToolResponse>> executeSyncTools(List<ToolCall> toolCalls) {
        // ä½¿ç”¨ä¸“ç”¨çš„çº¿ç¨‹æ± ï¼Œè€Œä¸æ˜¯å…¨å±€çš„boundedElastic
        Scheduler dedicatedScheduler = Schedulers.newBoundedElastic(
            100,  // æ›´å¤§çš„çº¿ç¨‹æ± 
            Integer.MAX_VALUE,  // æ— é™é˜Ÿåˆ—
            "tool-execution",
            60,
            true
        );
        
        return Flux.fromIterable(toolCalls)
            .flatMap(toolCall -> Mono.fromCallable(() -> {
                ToolCallback callback = resolveCallback(toolCall);
                return callback.call(toolCall.arguments(), toolContext);
            }).subscribeOn(dedicatedScheduler))
            .collectList();
    }
}
```

---

## ğŸ“Š **æ€§èƒ½å¯¹æ¯”**

### **å½“å‰æ–¹æ¡ˆ vs å¼‚æ­¥æ–¹æ¡ˆ**

| åœºæ™¯ | å½“å‰æ–¹æ¡ˆï¼ˆåŒæ­¥ï¼‰ | å¼‚æ­¥æ–¹æ¡ˆ | æ”¹è¿› |
|------|----------------|---------|------|
| **100å¹¶å‘ï¼Œ1ä¸ªå·¥å…·/2ç§’** | å¹³å‡å»¶è¿Ÿ 4ç§’ | å¹³å‡å»¶è¿Ÿ 2ç§’ | âœ… 50%æå‡ |
| **100å¹¶å‘ï¼Œ3ä¸ªå·¥å…·/2ç§’** | å¹³å‡å»¶è¿Ÿ 10ç§’ | å¹³å‡å»¶è¿Ÿ 2ç§’ | âœ… 80%æå‡ |
| **çº¿ç¨‹å ç”¨** | 80ä¸ªçº¿ç¨‹ï¼ˆä¸Šé™ï¼‰ | 0ä¸ªé˜»å¡çº¿ç¨‹ | âœ… æ— é™å¹¶å‘ |
| **èµ„æºåˆ©ç”¨ç‡** | 60-80% | 90-95% | âœ… æå‡30% |

---

## ğŸ¯ **æ¨èçš„å®æ–½è®¡åˆ’**

### **ç¬¬ä¸€é˜¶æ®µï¼ˆç«‹å³ï¼‰ï¼šé…ç½®ä¼˜åŒ–**
- âœ… è°ƒæ•´`boundedElastic`é…ç½®
- âœ… æ·»åŠ ç›‘æ§å‘Šè­¦
- âœ… å®æ–½é™çº§ç­–ç•¥
- **æˆæœ¬**ï¼š1äººå‘¨
- **æ”¶ç›Š**ï¼šç¼“è§£å½“å‰é—®é¢˜

### **ç¬¬äºŒé˜¶æ®µï¼ˆ1-2ä¸ªæœˆï¼‰ï¼šå¼‚æ­¥å·¥å…·æ”¯æŒ**
- âœ… è®¾è®¡`AsyncToolCallback`æ¥å£
- âœ… ä¿®æ”¹`ToolCallingManager`
- âœ… æ›´æ–°æ‰€æœ‰11ä¸ªæ¨¡å‹å®ç°
- **æˆæœ¬**ï¼š5-8äººå‘¨
- **æ”¶ç›Š**ï¼šè§£å†³æ ¸å¿ƒé—®é¢˜

### **ç¬¬ä¸‰é˜¶æ®µï¼ˆ3-6ä¸ªæœˆï¼‰ï¼šå®Œå…¨é‡æ„**
- âœ… æ™ºèƒ½è°ƒåº¦å™¨
- âœ… ä¸“ç”¨çº¿ç¨‹æ± 
- âœ… æµå¼å·¥å…·æ‰§è¡Œ
- **æˆæœ¬**ï¼š10-15äººå‘¨
- **æ”¶ç›Š**ï¼šæ€§èƒ½æå‡5-10å€

---

## âœ… **æ€»ç»“**

**é—®é¢˜æœ¬è´¨**ï¼š
- å¼‚æ­¥æµå¼å“åº” + åŒæ­¥é˜»å¡å·¥å…· = å¿…é¡»ä½¿ç”¨`boundedElastic`
- ä¸æ˜¯ä»£ç é”™è¯¯ï¼Œè€Œæ˜¯**æ¶æ„è®¾è®¡çš„å¿…ç„¶å¦¥å**

**å½±å“èŒƒå›´**ï¼š
- âœ… æ‰€æœ‰11ä¸ªæ”¯æŒFunction Callingçš„æ¨¡å‹
- âœ… åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ä¼šæˆä¸ºç“¶é¢ˆ

**è§£å†³æ–¹æ¡ˆ**ï¼š
- ğŸ”¶ çŸ­æœŸï¼šä¼˜åŒ–é…ç½®å’Œç›‘æ§ï¼ˆç«‹å³å¯åšï¼‰
- âœ… ä¸­æœŸï¼šæ”¯æŒå¼‚æ­¥å·¥å…·è°ƒç”¨ï¼ˆå½»åº•è§£å†³ï¼‰
- â­ é•¿æœŸï¼šå®Œå…¨å¼‚æ­¥æ¶æ„ï¼ˆæ€§èƒ½æœ€ä¼˜ï¼‰

**æŠ€æœ¯ä»·å€¼**ï¼š
- è¿™æ˜¯ä¸€ä¸ª**æ¶æ„çº§åˆ«çš„ä¼˜åŒ–**
- ä¸ä»…è§£å†³æ€§èƒ½é—®é¢˜ï¼Œè¿˜æ”¹å–„å¼€å‘è€…ä½“éªŒ
- ä¸ºæœªæ¥çš„æ‰©å±•æ‰“ä¸‹åŸºç¡€

---

## ğŸ”— **ç›¸å…³èµ„æº**

1. **Reactoræ–‡æ¡£**ï¼šhttps://projectreactor.io/docs/core/release/reference/
2. **Schedulersè¯¦è§£**ï¼šhttps://projectreactor.io/docs/core/release/reference/#schedulers
3. **Spring AIå·¥å…·è°ƒç”¨**ï¼šhttps://docs.spring.io/spring-ai/reference/api/tools.html
4. **å¼‚æ­¥ç¼–ç¨‹æœ€ä½³å®è·µ**ï¼šhttps://github.com/reactor/reactor-core/blob/main/docs/asciidoc/advancedFeatures.adoc

---

è¿™æ˜¯ä¸€ä¸ª**å€¼å¾—æ·±å…¥ç ”ç©¶çš„æŠ€æœ¯é—®é¢˜**ï¼Œè§£å†³å®ƒå°†æ˜¾è‘—æå‡Spring AIçš„æ€§èƒ½å’Œå¯æ‰©å±•æ€§ï¼

